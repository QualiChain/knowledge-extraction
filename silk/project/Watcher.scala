import java.io.File

import scala.collection.mutable
import scala.collection.mutable.HashMap
import scala.util.matching.Regex

/** Watches files for being modified */
object Watcher {
  private val watches = new HashMap[WatchConfig, WatchData]()

  /** Checks if files have changed since last check and updates watch data
    * @return The files that are not registered yet or have been modified, since the last check. */
  def filesChanged(watchConfig: WatchConfig): Iterable[File] = {
    val watchData = fetchWatchData(watchConfig)
    val changedFiles = mutable.HashSet.empty[File]

    watches.get(watchConfig) match {
      case Some(oldWatchData) =>
        if(watchData != oldWatchData) {
          watches.put(watchConfig, watchData)
          watchData.files.keys filter { file =>
            oldWatchData.files.get(file) match {
              case Some(oldFileInfo) =>
                watchData.files(file).modifiedTimestamp != oldFileInfo.modifiedTimestamp
              case None =>
                true // not existing, yet, so add
            }
          }
        } else {
          Seq.empty
        }
      case None =>
        watches.put(watchConfig, watchData)
        watchData.files.keys
    }
  }

  /** Checks if the target files have a later modified timestamp than all of the source files */
  def staleTargetFiles(sourceFilesWatchConfig: WatchConfig, targetFiles: Seq[File]): Boolean = {
    val sourceModificationTimes = fetchWatchData(sourceFilesWatchConfig).files.map(_._2.modifiedTimestamp).toSeq
    if(sourceModificationTimes.isEmpty || targetFiles.isEmpty) {
      false // No source data or target data, safer to return false
    } else {
      if(targetFiles.exists(!_.exists())) {
        true // One of the target files does not exist, generate
      } else {
        val maxSourceModificationTime = sourceModificationTimes.max
        val minTargetModificationTime = targetFiles.map(_.lastModified()).min
        minTargetModificationTime < maxSourceModificationTime
      }
    }
  }

  private def fetchWatchData(watchConfig: WatchConfig): WatchData = {
    val fileInfos = fetchFileInfos(watchConfig)
    WatchData(fileInfos)
  }

  private def fetchFileInfos(watchConfig: WatchConfig): Map[File, FileInfo] = {
    val files = fetchFileInfosRecursive(watchConfig.regex, watchConfig.directory)
    files map (file => {
      (
        file,
        FileInfo(file.lastModified())
      )
    }) toMap
  }

  private def fetchFileInfosRecursive(fileRegex: Regex, baseFile: File): Seq[File] = {
    val files = for(file <- baseFile.listFiles().toSeq) yield {
      if(file.isDirectory) {
        fetchFileInfosRecursive(fileRegex, file)
      } else {
        if(fileRegex.findFirstIn(file.getName).isDefined) {
          Seq(file)
        } else {
          Seq.empty
        }
      }
    }
    files.flatten
  }
}

/** The config for the files to be watched
  *
  * @param directory The base directory, files are watched recursively under this directory
  * @param fileRegex Regex for the files to be watched
  * */
case class WatchConfig(directory: File, fileRegex: String) {
  lazy val regex: Regex = fileRegex.r
}

case class WatchData(files: Map[File, FileInfo])

case class FileInfo(modifiedTimestamp: Long)